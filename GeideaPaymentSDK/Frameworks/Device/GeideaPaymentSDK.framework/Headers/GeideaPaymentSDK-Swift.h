// Generated by Apple Swift version 5.5 effective-4.1.50 (swiftlang-1300.0.31.1 clang-1300.0.29.1)
#ifndef GEIDEAPAYMENTSDK_SWIFT_H
#define GEIDEAPAYMENTSDK_SWIFT_H
#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wgcc-compat"

#if !defined(__has_include)
# define __has_include(x) 0
#endif
#if !defined(__has_attribute)
# define __has_attribute(x) 0
#endif
#if !defined(__has_feature)
# define __has_feature(x) 0
#endif
#if !defined(__has_warning)
# define __has_warning(x) 0
#endif

#if __has_include(<swift/objc-prologue.h>)
# include <swift/objc-prologue.h>
#endif

#pragma clang diagnostic ignored "-Wauto-import"
#include <Foundation/Foundation.h>
#include <stdint.h>
#include <stddef.h>
#include <stdbool.h>

#if !defined(SWIFT_TYPEDEFS)
# define SWIFT_TYPEDEFS 1
# if __has_include(<uchar.h>)
#  include <uchar.h>
# elif !defined(__cplusplus)
typedef uint_least16_t char16_t;
typedef uint_least32_t char32_t;
# endif
typedef float swift_float2  __attribute__((__ext_vector_type__(2)));
typedef float swift_float3  __attribute__((__ext_vector_type__(3)));
typedef float swift_float4  __attribute__((__ext_vector_type__(4)));
typedef double swift_double2  __attribute__((__ext_vector_type__(2)));
typedef double swift_double3  __attribute__((__ext_vector_type__(3)));
typedef double swift_double4  __attribute__((__ext_vector_type__(4)));
typedef int swift_int2  __attribute__((__ext_vector_type__(2)));
typedef int swift_int3  __attribute__((__ext_vector_type__(3)));
typedef int swift_int4  __attribute__((__ext_vector_type__(4)));
typedef unsigned int swift_uint2  __attribute__((__ext_vector_type__(2)));
typedef unsigned int swift_uint3  __attribute__((__ext_vector_type__(3)));
typedef unsigned int swift_uint4  __attribute__((__ext_vector_type__(4)));
#endif

#if !defined(SWIFT_PASTE)
# define SWIFT_PASTE_HELPER(x, y) x##y
# define SWIFT_PASTE(x, y) SWIFT_PASTE_HELPER(x, y)
#endif
#if !defined(SWIFT_METATYPE)
# define SWIFT_METATYPE(X) Class
#endif
#if !defined(SWIFT_CLASS_PROPERTY)
# if __has_feature(objc_class_property)
#  define SWIFT_CLASS_PROPERTY(...) __VA_ARGS__
# else
#  define SWIFT_CLASS_PROPERTY(...)
# endif
#endif

#if __has_attribute(objc_runtime_name)
# define SWIFT_RUNTIME_NAME(X) __attribute__((objc_runtime_name(X)))
#else
# define SWIFT_RUNTIME_NAME(X)
#endif
#if __has_attribute(swift_name)
# define SWIFT_COMPILE_NAME(X) __attribute__((swift_name(X)))
#else
# define SWIFT_COMPILE_NAME(X)
#endif
#if __has_attribute(objc_method_family)
# define SWIFT_METHOD_FAMILY(X) __attribute__((objc_method_family(X)))
#else
# define SWIFT_METHOD_FAMILY(X)
#endif
#if __has_attribute(noescape)
# define SWIFT_NOESCAPE __attribute__((noescape))
#else
# define SWIFT_NOESCAPE
#endif
#if __has_attribute(ns_consumed)
# define SWIFT_RELEASES_ARGUMENT __attribute__((ns_consumed))
#else
# define SWIFT_RELEASES_ARGUMENT
#endif
#if __has_attribute(warn_unused_result)
# define SWIFT_WARN_UNUSED_RESULT __attribute__((warn_unused_result))
#else
# define SWIFT_WARN_UNUSED_RESULT
#endif
#if __has_attribute(noreturn)
# define SWIFT_NORETURN __attribute__((noreturn))
#else
# define SWIFT_NORETURN
#endif
#if !defined(SWIFT_CLASS_EXTRA)
# define SWIFT_CLASS_EXTRA
#endif
#if !defined(SWIFT_PROTOCOL_EXTRA)
# define SWIFT_PROTOCOL_EXTRA
#endif
#if !defined(SWIFT_ENUM_EXTRA)
# define SWIFT_ENUM_EXTRA
#endif
#if !defined(SWIFT_CLASS)
# if __has_attribute(objc_subclassing_restricted)
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_subclassing_restricted)) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# else
#  define SWIFT_CLASS(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
#  define SWIFT_CLASS_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_CLASS_EXTRA
# endif
#endif
#if !defined(SWIFT_RESILIENT_CLASS)
# if __has_attribute(objc_class_stub)
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME) __attribute__((objc_class_stub))
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) __attribute__((objc_class_stub)) SWIFT_CLASS_NAMED(SWIFT_NAME)
# else
#  define SWIFT_RESILIENT_CLASS(SWIFT_NAME) SWIFT_CLASS(SWIFT_NAME)
#  define SWIFT_RESILIENT_CLASS_NAMED(SWIFT_NAME) SWIFT_CLASS_NAMED(SWIFT_NAME)
# endif
#endif

#if !defined(SWIFT_PROTOCOL)
# define SWIFT_PROTOCOL(SWIFT_NAME) SWIFT_RUNTIME_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
# define SWIFT_PROTOCOL_NAMED(SWIFT_NAME) SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_PROTOCOL_EXTRA
#endif

#if !defined(SWIFT_EXTENSION)
# define SWIFT_EXTENSION(M) SWIFT_PASTE(M##_Swift_, __LINE__)
#endif

#if !defined(OBJC_DESIGNATED_INITIALIZER)
# if __has_attribute(objc_designated_initializer)
#  define OBJC_DESIGNATED_INITIALIZER __attribute__((objc_designated_initializer))
# else
#  define OBJC_DESIGNATED_INITIALIZER
# endif
#endif
#if !defined(SWIFT_ENUM_ATTR)
# if defined(__has_attribute) && __has_attribute(enum_extensibility)
#  define SWIFT_ENUM_ATTR(_extensibility) __attribute__((enum_extensibility(_extensibility)))
# else
#  define SWIFT_ENUM_ATTR(_extensibility)
# endif
#endif
#if !defined(SWIFT_ENUM)
# define SWIFT_ENUM(_type, _name, _extensibility) enum _name : _type _name; enum SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# if __has_feature(generalized_swift_name)
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) enum _name : _type _name SWIFT_COMPILE_NAME(SWIFT_NAME); enum SWIFT_COMPILE_NAME(SWIFT_NAME) SWIFT_ENUM_ATTR(_extensibility) SWIFT_ENUM_EXTRA _name : _type
# else
#  define SWIFT_ENUM_NAMED(_type, _name, SWIFT_NAME, _extensibility) SWIFT_ENUM(_type, _name, _extensibility)
# endif
#endif
#if !defined(SWIFT_UNAVAILABLE)
# define SWIFT_UNAVAILABLE __attribute__((unavailable))
#endif
#if !defined(SWIFT_UNAVAILABLE_MSG)
# define SWIFT_UNAVAILABLE_MSG(msg) __attribute__((unavailable(msg)))
#endif
#if !defined(SWIFT_AVAILABILITY)
# define SWIFT_AVAILABILITY(plat, ...) __attribute__((availability(plat, __VA_ARGS__)))
#endif
#if !defined(SWIFT_WEAK_IMPORT)
# define SWIFT_WEAK_IMPORT __attribute__((weak_import))
#endif
#if !defined(SWIFT_DEPRECATED)
# define SWIFT_DEPRECATED __attribute__((deprecated))
#endif
#if !defined(SWIFT_DEPRECATED_MSG)
# define SWIFT_DEPRECATED_MSG(...) __attribute__((deprecated(__VA_ARGS__)))
#endif
#if __has_feature(attribute_diagnose_if_objc)
# define SWIFT_DEPRECATED_OBJC(Msg) __attribute__((diagnose_if(1, Msg, "warning")))
#else
# define SWIFT_DEPRECATED_OBJC(Msg) SWIFT_DEPRECATED_MSG(Msg)
#endif
#if !defined(IBSegueAction)
# define IBSegueAction
#endif
#if __has_feature(modules)
#if __has_warning("-Watimport-in-framework-header")
#pragma clang diagnostic ignored "-Watimport-in-framework-header"
#endif
@import Foundation;
@import ObjectiveC;
@import PassKit;
#endif

#pragma clang diagnostic ignored "-Wproperty-attribute-mismatch"
#pragma clang diagnostic ignored "-Wduplicate-method-arg"
#if __has_warning("-Wpragma-clang-attribute")
# pragma clang diagnostic ignored "-Wpragma-clang-attribute"
#endif
#pragma clang diagnostic ignored "-Wunknown-pragmas"
#pragma clang diagnostic ignored "-Wnullability"

#if __has_attribute(external_source_symbol)
# pragma push_macro("any")
# undef any
# pragma clang attribute push(__attribute__((external_source_symbol(language="Swift", defined_in="GeideaPaymentSDK",generated_declaration))), apply_to=any(function,enum,objc_interface,objc_category,objc_protocol))
# pragma pop_macro("any")
#endif

typedef SWIFT_ENUM(NSInteger, CardType, closed) {
  CardTypeAmex = 0,
  CardTypeVisa = 1,
  CardTypeMasterCard = 2,
  CardTypeMada = 3,
};


SWIFT_CLASS("_TtC16GeideaPaymentSDK23ConfigCountriesResponse")
@interface ConfigCountriesResponse : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

typedef SWIFT_ENUM(NSInteger, Environment, closed) {
  EnvironmentDev = 0,
  EnvironmentTest = 1,
  EnvironmentPreprod = 2,
  EnvironmentProd = 3,
};

@class NSString;

SWIFT_CLASS("_TtC16GeideaPaymentSDK9GDAddress")
@interface GDAddress : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithCountryCode:(NSString * _Nullable)countryCode andCity:(NSString * _Nullable)city andStreet:(NSString * _Nullable)street andPostCode:(NSString * _Nullable)postCode OBJC_DESIGNATED_INITIALIZER;
@end

@class NSNumber;

SWIFT_CLASS("_TtC16GeideaPaymentSDK8GDAmount")
@interface GDAmount : NSObject
- (nonnull instancetype)initWithAmount:(double)amount currency:(NSString * _Nonnull)currency OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class UIViewController;
@class UIView;

SWIFT_CLASS("_TtC16GeideaPaymentSDK17GDApplePayDetails")
@interface GDApplePayDetails : NSObject
- (nonnull instancetype)initIn:(UIViewController * _Nullable)hostViewController andButtonIn:(UIView * _Nullable)buttonView forMerchantIdentifier:(NSString * _Nonnull)merchantIdentifier andMerchantDisplayName:(NSString * _Nullable)merchantDisplayName requiredBillingContactFields:(NSSet<PKContactField> * _Nullable)requiredBillingContactFields requiredShippingContactFields:(NSSet<PKContactField> * _Nullable)requiredShippingContactFields withCallbackUrl:(NSString * _Nullable)callBackUrl andReferenceId:(NSString * _Nullable)merchantRefId OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK18GDApplePayResponse")
@interface GDApplePayResponse : NSObject
@property (nonatomic, copy) NSString * _Nonnull responseCode;
@property (nonatomic, copy) NSString * _Nonnull responseMessage;
@property (nonatomic, copy) NSString * _Nonnull detailedResponseCode;
@property (nonatomic, copy) NSString * _Nonnull detailedResponseMessage;
@property (nonatomic, copy) NSString * _Nonnull orderId;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK31GDAuthenticationDetailsResponse")
@interface GDAuthenticationDetailsResponse : NSObject
@property (nonatomic, copy) NSString * _Nullable acsEci;
@property (nonatomic, copy) NSString * _Nullable paResStatus;
@property (nonatomic, copy) NSString * _Nullable proofXml;
@property (nonatomic, copy) NSString * _Nullable veResEnrolled;
@property (nonatomic, copy) NSString * _Nullable authenticationToken;
@property (nonatomic, copy) NSString * _Nullable xid;
@property (nonatomic, copy) NSString * _Nullable accountAuthenticationValue;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK16GDCancelResponse")
@interface GDCancelResponse : NSObject
@property (nonatomic, copy) NSString * _Nullable orderId;
@property (nonatomic, copy) NSString * _Nullable responseCode;
@property (nonatomic, copy) NSString * _Nullable responseMessage;
@property (nonatomic, copy) NSString * _Nullable detailedResponseMessage;
@property (nonatomic, copy) NSString * _Nullable detailedResponseCode;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK13GDCardDetails")
@interface GDCardDetails : NSObject
- (nonnull instancetype)initWithCardholderName:(NSString * _Nonnull)cardholderName andCardNumber:(NSString * _Nonnull)cardNumber andCVV:(NSString * _Nonnull)cvv andExpiryMonth:(NSInteger)expiryMonth andExpiryYear:(NSInteger)expiryYear OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK16GDConfigApplePay")
@interface GDConfigApplePay : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK16GDConfigResponse")
@interface GDConfigResponse : NSObject
@property (nonatomic) NSInteger hppDefaultTimeout;
@property (nonatomic, copy) NSArray<ConfigCountriesResponse *> * _Nullable countries;
@property (nonatomic, copy) NSString * _Nullable detailedResponseMessage;
@property (nonatomic, copy) NSString * _Nullable detailedResponseCode;
@property (nonatomic, copy) NSString * _Nullable responseMessage;
@property (nonatomic, copy) NSString * _Nullable responseCode;
@property (nonatomic, copy) NSString * _Nullable name;
@property (nonatomic, strong) GDConfigApplePay * _Nullable applePay;
@property (nonatomic, copy) NSArray<NSString *> * _Nullable paymentMethods;
@property (nonatomic, copy) NSArray<NSString *> * _Nullable currencies;
@property (nonatomic, copy) NSString * _Nullable merchantName;
@property (nonatomic, copy) NSArray<NSString *> * _Nullable allowedInitiatedByValues;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

enum PaymentOperation : NSInteger;

SWIFT_CLASS("_TtC16GeideaPaymentSDK17GDCustomerDetails")
@interface GDCustomerDetails : NSObject
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)initWithEmail:(NSString * _Nullable)email andCallbackUrl:(NSString * _Nullable)callbackUrl merchantReferenceId:(NSString * _Nullable)merchantReferenceId shippingAddress:(GDAddress * _Nullable)shippingAddress billingAddress:(GDAddress * _Nullable)billingAddress paymentOperation:(enum PaymentOperation)paymentOperation OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK18GDEInvoiceCustomer")
@interface GDEInvoiceCustomer : NSObject
@property (nonatomic, copy) NSString * _Nullable email;
@property (nonatomic, copy) NSString * _Nullable phone;
@property (nonatomic, copy) NSString * _Nullable name;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class NSDate;

SWIFT_CLASS("_TtC16GeideaPaymentSDK17GDEInvoiceDetails")
@interface GDEInvoiceDetails : NSObject
- (nonnull instancetype)initWithAmount:(GDAmount * _Nonnull)amount andExpiryDate:(NSDate * _Nullable)expiryDate andName:(NSString * _Nonnull)name andEmail:(NSString * _Nullable)email andPhoneNumber:(NSString * _Nullable)phoneNumber eInvoiceId:(NSString * _Nullable)eInvoiceId OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

@class GDInvoiceResponse;

SWIFT_CLASS("_TtC16GeideaPaymentSDK18GDEInvoiceResponse")
@interface GDEInvoiceResponse : NSObject
@property (nonatomic, strong) GDInvoiceResponse * _Nullable eInvoice;
@property (nonatomic, copy) NSString * _Nullable responseMessage;
@property (nonatomic, copy) NSString * _Nullable detailedResponseMessage;
@property (nonatomic, copy) NSString * _Nullable responseCode;
@property (nonatomic, copy) NSString * _Nullable detailedResponseCode;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK15GDErrorResponse")
@interface GDErrorResponse : NSObject
@property (nonatomic, copy) NSDictionary<NSString *, NSArray<NSString *> *> * _Nonnull errors;
@property (nonatomic) NSInteger status;
@property (nonatomic, copy) NSString * _Nonnull title;
@property (nonatomic, copy) NSString * _Nonnull traceId;
@property (nonatomic, copy) NSString * _Nonnull type;
@property (nonatomic, copy) NSString * _Nonnull responseCode;
@property (nonatomic, copy) NSString * _Nonnull responseMessage;
@property (nonatomic, copy) NSString * _Nonnull detailedResponseCode;
@property (nonatomic, copy) NSString * _Nonnull detailedResponseMessage;
@property (nonatomic, copy) NSString * _Nonnull orderId;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK17GDInvoiceResponse")
@interface GDInvoiceResponse : NSObject
@property (nonatomic, copy) NSString * _Nullable eInvoiceId;
@property (nonatomic, copy) NSString * _Nullable currency;
@property (nonatomic, strong) GDEInvoiceCustomer * _Nullable customer;
@property (nonatomic, copy) NSString * _Nullable merchantPublicKey;
@property (nonatomic, copy) NSString * _Nullable expiryDate;
@property (nonatomic, copy) NSString * _Nullable status;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class GDTransactionResponse;
@class GDPaymentMethodResponse;

SWIFT_CLASS("_TtC16GeideaPaymentSDK15GDOrderResponse")
@interface GDOrderResponse : NSObject
@property (nonatomic, copy) NSString * _Nullable merchantReferenceId;
@property (nonatomic, copy) NSString * _Nullable orderId;
@property (nonatomic, copy) NSString * _Nullable threeDSecureId;
@property (nonatomic, copy) NSString * _Nullable status;
@property (nonatomic, copy) NSString * _Nullable eInvoiceId;
@property (nonatomic) double amount;
@property (nonatomic) double totalRefundedAmount;
@property (nonatomic, copy) NSString * _Nullable merchantPublicKey;
@property (nonatomic, copy) NSString * _Nullable currency;
@property (nonatomic, copy) NSString * _Nullable updatedDate;
@property (nonatomic) double totalAuthorizedAmount;
@property (nonatomic, copy) NSString * _Nullable customerEmail;
@property (nonatomic) double totalCapturedAmount;
@property (nonatomic, copy) NSString * _Nullable createdBy;
@property (nonatomic, copy) NSArray<GDTransactionResponse *> * _Nullable transactions;
@property (nonatomic, copy) NSString * _Nullable createdDate;
@property (nonatomic, copy) NSString * _Nullable merchantId;
@property (nonatomic, copy) NSString * _Nullable updatedBy;
@property (nonatomic, strong) GDAddress * _Nullable shippingAddress;
@property (nonatomic, strong) GDAddress * _Nullable billingAddress;
@property (nonatomic, strong) GDPaymentMethodResponse * _Nullable paymentMethod;
@property (nonatomic, copy) NSString * _Nullable returnUrl;
@property (nonatomic, copy) NSString * _Nullable detailedStatus;
@property (nonatomic, copy) NSString * _Nullable callbackUrl;
@property (nonatomic) BOOL cardOnFile;
@property (nonatomic, copy) NSString * _Nullable tokenId;
@property (nonatomic, copy) NSString * _Nullable initiatedBy;
@property (nonatomic, copy) NSString * _Nullable agreementId;
@property (nonatomic, copy) NSString * _Nullable agreementType;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK14GDOrdersFilter")
@interface GDOrdersFilter : NSObject
@property (nonatomic, copy) NSArray<NSString *> * _Nullable DetailedStatuses;
@property (nonatomic, copy) NSString * _Nullable Status;
@property (nonatomic, copy) NSString * _Nullable UpdatedDate;
@property (nonatomic, copy) NSString * _Nullable FromDate;
@property (nonatomic, copy) NSString * _Nullable ToDate;
@property (nonatomic) NSInteger Skip;
@property (nonatomic) NSInteger Take;
- (nonnull instancetype)initWithStatus:(NSString * _Nullable)status andDetailedStatuses:(NSArray<NSString *> * _Nullable)detailedStatuses andUpdatedDate:(NSString * _Nullable)updatedDate from:(NSString * _Nullable)fromDate to:(NSString * _Nullable)toDate skip:(NSInteger)skip take:(NSInteger)take OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK16GDOrdersResponse")
@interface GDOrdersResponse : NSObject
@property (nonatomic, copy) NSArray<GDOrderResponse *> * _Nullable orders;
@property (nonatomic) NSInteger totalCount;
@property (nonatomic, copy) NSString * _Nullable detailedResponseMessage;
@property (nonatomic, copy) NSString * _Nullable detailedResponseCode;
@property (nonatomic, copy) NSString * _Nullable responseMessage;
@property (nonatomic, copy) NSString * _Nullable responseCode;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK23GDPaymentMethodResponse")
@interface GDPaymentMethodResponse : NSObject
@property (nonatomic, copy) NSString * _Nullable type;
@property (nonatomic, copy) NSString * _Nullable brand;
@property (nonatomic, copy) NSString * _Nullable cardholderName;
@property (nonatomic, copy) NSString * _Nullable maskedCardNumber;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK21GDTokenizationDetails")
@interface GDTokenizationDetails : NSObject
- (nonnull instancetype)initWithCardOnFile:(BOOL)isCardOnFile initiatedBy:(NSString * _Nullable)initiatedBy agreementId:(NSString * _Nullable)agreementId agreementType:(NSString * _Nullable)agreementType OBJC_DESIGNATED_INITIALIZER;
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end


SWIFT_CLASS("_TtC16GeideaPaymentSDK21GDTransactionResponse")
@interface GDTransactionResponse : NSObject
@property (nonatomic, strong) GDAuthenticationDetailsResponse * _Nullable authenticationDetails;
@property (nonatomic) double amount;
@property (nonatomic, copy) NSString * _Nullable createdDate;
@property (nonatomic, copy) NSString * _Nullable createdBy;
@property (nonatomic, copy) NSString * _Nullable updatedDate;
@property (nonatomic, copy) NSString * _Nullable updatedBy;
@property (nonatomic, copy) NSString * _Nullable transactionId;
@property (nonatomic, copy) NSString * _Nullable type;
@property (nonatomic, copy) NSString * _Nullable status;
@property (nonatomic, copy) NSString * _Nullable currency;
@property (nonatomic, copy) NSString * _Nullable source;
@property (nonatomic, copy) NSString * _Nullable authorizationCode;
@property (nonatomic, copy) NSString * _Nullable rrn;
@property (nonatomic, strong) GDPaymentMethodResponse * _Nullable paymentMethod;
- (nonnull instancetype)init OBJC_DESIGNATED_INITIALIZER;
@end

@class UIImage;

SWIFT_CLASS("_TtC16GeideaPaymentSDK16GeideaPaymentAPI")
@interface GeideaPaymentAPI : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
/// Check if  login storage already available in SDK
/// <h1>Examples</h1>
/// Add this to check if credentials are already stored in the SDK Secure storage
/// \code
/// if !GeideaPaymentAPI .isCredentialsAvailable() {
/// GeideaPaymentAPI.setCredentials(withMerchantKey:  "publicKey", andPassword: "password")
/// }
///
/// \endcode\code
/// if (![GeideaPaymentAPI isCredentialsAvailable]) {
/// [GeideaPaymentAPI setCredentialsWithMerchantKey: @"merchantPublicKey" andPassword: @"merchantPassword"];
/// }
///
/// \endcodesince:
/// 1.0
/// version:
/// 1.0
+ (BOOL)isCredentialsAvailable SWIFT_WARN_UNUSED_RESULT;
/// Set login credentials / authenticate in SDK with merchat publicKey and password
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     merchantKey:String - The Geidea assigned merchantPublicKey. <em>Required</em>
///   </li>
///   <li>
///     password:String - The Geidea assigned password. <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// Add this to check if credentials are already stored in the SDK Secure storage
/// \code
/// if !GeideaPaymentAPI .isCredentialsAvailable() {
/// GeideaPaymentAPI.setCredentials(withMerchantKey:  "merchantKey", andPassword: "password")
/// }
///
/// \endcode\code
/// if (![GeideaPaymentAPI isCredentialsAvailable]) {
/// [GeideaPaymentAPI setCredentialsWithMerchantKey: @"merchantPublicKey" andPassword: @"merchantPassword"];
/// }
///
/// \endcodeattention:
/// Be sure to authenticate your app with  SDK before continue with payment process  <em>pay</em>
/// since:
/// 1.0
/// version:
/// 1.0
+ (void)setCredentialsWithMerchantKey:(NSString * _Nonnull)merchantKey andPassword:(NSString * _Nonnull)password;
/// Starting the payment flow
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     amount: GDAmount - SDK GDAmount object  <em>Required</em>
///     amount: Double <em>Required</em>
///     currency: String <em>Required</em>
///   </li>
///   <li>
///     cardDetails: GDCardDetails - SDK GDCardDetails object  <em>Required</em>
///     cardholderName: String <em>Required</em>
///     cardNumber: String <em>Required</em>
///     cvv: String <em>Required</em>
///     expiryYear: Int <em>Required</em>
///     expiryMonth: Int <em>Required</em>
///   </li>
///   <li>
///     tokenizationDetails: GDTokenizationDetails <em>Optional</em>
///     cardOnFile: Bool <em>Optional</em> true for tokenization
///     initiatedBy: String <em>Optional</em> Must be “Internet” if card On file true
///     agreementID: String <em>Optional</em> Any value
///     agreementType String <em>Optional</em> e.g “Recurring” , “installment” ,“Unscheduled” , etc
///   </li>
///   <li>
///     eInvoice: String  <em>Optional</em> EInvoice id for paying an EInvoice created before
///   </li>
///   <li>
///     customerDetails: GDCustomerDetails - SDK GDCustomerDetails object use for internal customer reference for customer info  . <em>Optional</em>
///     customerEmail: String <em>Optional</em>
///     callbackUrl: String <em>Optional</em>
///     merchantReferenceId: String <em>Optional</em>
///     paymentOperation: PaymentOperation <em>Optional</em>
///   </li>
///   <li>
///     shippingAddress: GDAddress <em>Optional</em>
///     countryCode: String <em>Optional</em>
///     city: String <em>Optional</em>
///     street: String <em>Optional</em>
///     postCode: String <em>Optional</em>
///   </li>
///   <li>
///     billingAddress: GDAddress <em>Optional</em>
///     countryCode: String <em>Optional</em>
///     city: String <em>Optional</em>
///     street: String <em>Optional</em>
///     postCode: String <em>Optional</em>
///   </li>
///   <li>
///     navController: UIViewController - Used for presenting SDK Payment flow. <em>Required</em>
///     two options for starting the SDK:
///     self type of : (UIViewController) the SDK will present modally from customer app UIViewController
///     navigationController type of: UINavigationController  the SDK will be pushed from customer app NavigationCotroller
///   </li>
///   <li>
///     completion: (GDOrderResponse?, GDErrorResponse?)  -> Void - The completion handler for customer app returned from SDK <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// Starting the payment flow
/// \code
/// let amount = GDAmount(amount: Double, currency: String)
/// let cardDetails = GDCardDetails(withCardholderName: cardHolderName: String, andCardNumber:  cardNumber: String, andCVV: cvv: String, andExpiryMonth: expiryMonth: Int)
/// let tokenizationDetails = GDTokenizationDetails(withCardOnFile:Bool (true if the card will be tokenized), initiatedBy:  "Internet" (can be null if cardOnFile false otherwise mandatory), agreementId: String, String)
/// let shippingAddress = GDAddress(withCountryCode: shippingCountryCode: String, andCity: shippingCity: String, andStreet: shippingStreet: String, andPostCode: shippingPostalCode: String)
/// let billingAddress = GDAddress(withCountryCode: billingCountryCode: String, andCity: billingCity: String, andStreet: billingStreet: String, andPostCode: billingPostalCode: String)
/// let customerDetails = GDCustomerDetails(withEmail: email: String, andCallbackUrl: callback: String, merchantReferenceId: merchantRefid: String, shippingAddress: shippingAddress, billingAddress: billingAddress, paymentOperation: .pay or .preAuthorize etc..)
///
/// guard let navVC = UIApplication.shared.keyWindow?.rootViewController as? UINavigationController  else {
/// return
/// }
///
/// GeideaPaymentAPI.pay(theAmount: amount, withCardDetails: cardDetails, andTokenizationDetails: tokenizationDetails, andEInvoice: eInvoiceId,andCustomerDetails: customerDetails, navController: **navVC** or **self**, completion:{ response, error in
/// DispatchQueue.main.async {
///
/// if let err = error {
///    if err.errors.isEmpty {
///        var message = ""
///        if err.responseCode.isEmpty {
///        message = "\n responseMessage: \(err.responseMessage)"
///    } else {
///        message = "\n responseCode: \(err.responseCode)  \n responseMessage: \(err.responseMessage)"
///    }
///    //TODO: display relevant fields from GDErrorResponse
/// } else {
///    //TODO: display relevant fields from GDErrorResponse
/// }
///
/// } else {
/// guard let orderResponse = response else {
/// return
/// }
///
/// //TODO: display relevant fields from GDOrderResponse
/// //TODO: if cardOnFile is true save tokenId from GDOrderResponse in persistence and also agreementId and agreementType for subscriptions
/// //TODO: if paymentOperation is PaymentOperation.preAuthorize:
/// // Save order id in persistence for capturing the payment with // GeideaPaymentApi.capture
/// // if orderResponse.detailedStatus == "Authorized" {
/// // TODO: save order.orderId
/// // }
/// }
/// }
/// })
///
/// \endcode\code
/// UINavigationController *navVC =  (UINavigationController *)[[[UIApplication sharedApplication] keyWindow] rootViewController];
///
/// GDAmount *amount = [[GDAmount alloc] initWithAmount: [amunt doubleValue] currency: NSString *curency];
///
/// GDCardDetails *cardDetails = [[GDCardDetails alloc] initWithCardholderName: NSString *cardHolderName andCardNumber: NSString *cardNumber andCVV: NSString *cvv andExpiryMonth: [expiryMonth integerValue] andExpiryYear: [expiryYear integerValue]];
///
/// GDTokenizationDetails *tokenizationDetails = [[GDTokenizationDetails alloc] initWithCardOnFile:Bool initiatedBy: NSString  agreementId:NSString agreementType:NSString];
///
/// GDAddress *shippingAddress = [[GDAddress alloc] initWithCountryCode:NSString *shippingCountryCode andCity:_shippingCityTF.text andStreet:_shippingStreetTF.text andPostCode:_shippingPostCodeTF.text];
///
/// GDAddress *billingAddress = [[GDAddress alloc] initWithCountryCode:_billingCountryCodeTF.text andCity:_billingCityTF.text andStreet:_billingStreetTF.text andPostCode:_billingPostCodeTF.text];
///
/// GDCustomerDetails *customerDetails = [[GDCustomerDetails alloc] initWithEmail:_emailTF.text andCallbackUrl:_callbackUrlTF.text merchantReferenceId:_merchantRefIDTF.text shippingAddress:shippingAddress billingAddress:billingAddress paymentOperation: PaymentOperationPay];
///
/// [GeideaPaymentAPI payWithTheAmount:amount withCardDetails:cardDetails  andTokenizationDetails: tokenizationDetails andEInvoice: eInvoiceId andCustomerDetails:customerDetails dismissAction:NULL navController: **navVC** or **self** completion:^(GDOrderResponse* order, GDErrorResponse* error) {
///
/// if (error != NULL) {
/// if (!error.errors || !error.errors.count) {
/// NSString *message;
/// if ( [error.responseCode length] == 0) {
/// message = [NSString stringWithFormat:@"\n responseMessage: %@", error.responseMessage];
/// } else {
/// message = [NSString stringWithFormat:@"\n responseCode: %@ \n responseMessage: %@ ", error.responseCode , error.responseMessage];
/// }
///
/// //TODO: display relevant fields from GDErrorResponse
/// } else {
/// //TODO: display relevant fields from GDErrorResponse
/// }
///
/// } else {
/// if (order != NULL) {
/// //TODO: display relevant fields from GDOrderResponse
/// //TODO: if cardOnFile is true save tokenId from GDOrderResponse in persistence and also agreementId and agreementType for subscriptions (InitistedBy = "Merchant")
/// // TODO: check  [order tokenId] != NULL
/// //TODO: if paymentOperation is PaymentOperation.preAuthorize:
/// Save order id in persistence for capturing the payment with // GeideaPaymentApi.capture
/// if ([[order detailedStatus] isEqual: @"Authorized"]) {
/// TODO: save order.orderId
/// }
/// }
/// }
/// }];
///
/// \endcodeseealso:
/// GDAmount, GDCardDetails, GDTokenizationDetails, GDCustomerDetails, GDAddress, GDOrderResponse, GDErrorResponse
/// since:
/// 1.0
/// version:
/// 1.0
+ (void)payWithTheAmount:(GDAmount * _Nonnull)amount withCardDetails:(GDCardDetails * _Nonnull)cardDetails andTokenizationDetails:(GDTokenizationDetails * _Nullable)tokenizationDetails andEInvoice:(NSString * _Nullable)eInvoiceId andCustomerDetails:(GDCustomerDetails * _Nullable)customerDetails orderId:(NSString * _Nullable)orderId dismissAction:(void (^ _Nullable)(GDCancelResponse * _Nullable, GDErrorResponse * _Nullable))dismissAction navController:(UIViewController * _Nonnull)navController completion:(void (^ _Nonnull)(GDOrderResponse * _Nullable, GDErrorResponse * _Nullable))completion;
/// Starting the payment flow using Geidea Form
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     amount: GDAmount - SDK GDAmount object  <em>Required</em>
///     amount: Double <em>Required</em>
///     currency: String <em>Required</em>
///   </li>
///   <li>
///     showAddress: Bool  <em>Required</em> true or false if you use your own addresses form
///   </li>
///   <li>
///     showEmail: Bool  <em>Required</em> true or false if you use your own email form
///   </li>
///   <li>
///     tokenizationDetails: GDTokenizationDetails <em>Optional</em>
///     cardOnFile: Bool <em>Optional</em> true for tokenization
///     initiatedBy: String <em>Optional</em> Must be “Internet” if card On file true
///     agreementID: String <em>Optional</em> mercha
///     agreementType String <em>Optional</em> e.g “Recurring” , “installment” ,“Unscheduled” , etc
///   </li>
///   <li>
///     applePayDetails: GDApplePayDetails - SDK GDApplePayDetails <em>Optional</em> necessary if you want to use this feature
///   </li>
///   <li>
///     config: GDConfigResponse - SDK GDConfigResponse <em>Optional</em> if you provide your saved config, otherwise it will be refreshed inside the form
///   </li>
///   <li>
///     customerDetails: GDCustomerDetails - SDK GDCustomerDetails object use for internal customer reference for customer info . if you use it with showAddress and showEmail, form will be completed automatically with details provided <em>Optional</em>
///     customerEmail: String <em>Optional</em>
///     callbackUrl: String <em>Optional</em>
///     merchantReferenceId: String <em>Optional</em>
///     paymentOperation: PaymentOperation <em>Optional</em>
///   </li>
///   <li>
///     shippingAddress: GDAddress <em>Optional</em>
///     countryCode: String <em>Optional</em>
///     city: String <em>Optional</em>
///     street: String <em>Optional</em>
///     postCode: String <em>Optional</em>
///   </li>
///   <li>
///     billingAddress: GDAddress <em>Optional</em>
///     countryCode: String <em>Optional</em>
///     city: String <em>Optional</em>
///     street: String <em>Optional</em>
///     postCode: String <em>Optional</em>
///   </li>
///   <li>
///     eInvoiceId: String  <em>Optional</em> EInvoice id for paying an EInvoice created before
///   </li>
///   <li>
///     navController: UIViewController - Used for presenting SDK Payment flow. <em>Required</em>
///     self type of : (UIViewController) the SDK will present modally from customer app UIViewController
///   </li>
///   <li>
///     completion: (GDOrderResponse?, GDErrorResponse?)  -> Void - The completion handler for customer app returned from SDK <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// Starting the payment flow
/// \code
/// let amount = GDAmount(amount: Double, currency: String)
/// let tokenizationDetails = GDTokenizationDetails(withCardOnFile:Bool (true if the card will be tokenized), initiatedBy:  "Internet" (can be null if cardOnFile false otherwise mandatory), agreementId: String, agreementType: String)
/// let applePayDetails = GDApplePayDetails(in: self, andButtonIn: applePayBtnView, forMerchantIdentifier: "merchant.company. etc.", withCallbackUrl: String, andReferenceId: String)
///
/// GeideaPaymentAPI.payWithGeideaForm(theAmount: amount, showAddress: Bool, showEmail: Bool, tokenizationDetails: tokenizationDetails, customerDetails: customerDetails, applePayDetails: applePayDetails, config: self.merchantConfig, eInvoiceId: eInvoiceId, navController: self, completion:{ response, error in
/// DispatchQueue.main.async {
///
/// if let err = error {
/// if err.errors.isEmpty {
/// var message = ""
/// if err.responseCode.isEmpty {
/// message = "\n responseMessage: \(err.responseMessage)"
/// } else {
/// message = "\n responseCode: \(err.responseCode)  \n responseMessage: \(err.responseMessage)"
/// }
/// //TODO: display relevant fields from GDErrorResponse
/// } else {
/// //TODO: display relevant fields from GDErrorResponse
/// }
///
/// } else {
/// guard let orderResponse = response else {
/// return
/// }
///
/// //TODO: display relevant fields from GDOrderResponse
/// //TODO: if cardOnFile is true save tokenId from GDOrderResponse in persistence and also agreementId and agreementType for subscriptions
/// //TODO: if paymentOperation is PaymentOperation.preAuthorize:
/// // Save order id in persistence for capturing the payment with // GeideaPaymentApi.capture
/// // if orderResponse.detailedStatus == "Authorized" {
/// // TODO: save order.orderId
/// // }
/// }
/// }
/// })
///
/// \endcode\code
/// UINavigationController *navVC =  (UINavigationController *)[[[UIApplication sharedApplication] keyWindow] rootViewController];
///
/// GDAmount *amount = [[GDAmount alloc] initWithAmount: [amunt doubleValue] currency: NSString *curency];
///
/// GDTokenizationDetails *tokenizationDetails = [[GDTokenizationDetails alloc] initWithCardOnFile:Bool initiatedBy: NSString  agreementId:NSString agreementType:NSString];
///
/// GDApplePayDetails *applePayDetails = [[GDApplePayDetails alloc] initIn:self andButtonIn:_applePayBtnView forMerchantIdentifier:@"merchant.etc" withCallbackUrl:String andReferenceId:String];
///
///
/// [GeideaPaymentAPI payWithGeideaFormWithTheAmount:amount showAddress:Bool showEmail:Bool tokenizationDetails:tokenizationDetails customerDetails:NULL applePayDetails:applePayDetails config:self.config eInvoiceId: eInvoiceId navController: **self** completion:^(GDOrderResponse* order, GDErrorResponse* error) {
///
/// if (error != NULL) {
/// if (!error.errors || !error.errors.count) {
/// NSString *message;
/// if ( [error.responseCode length] == 0) {
/// message = [NSString stringWithFormat:@"\n responseMessage: %@", error.responseMessage];
/// } else {
/// message = [NSString stringWithFormat:@"\n responseCode: %@ \n responseMessage: %@ ", error.responseCode , error.responseMessage];
/// }
///
/// //TODO: display relevant fields from GDErrorResponse
/// } else {
/// //TODO: display relevant fields from GDErrorResponse
/// }
///
/// } else {
/// if (order != NULL) {
/// //TODO: display relevant fields from GDOrderResponse
/// //TODO: if cardOnFile is true save tokenId from GDOrderResponse in persistence and also agreementId and agreementType for subscriptions (InitistedBy = "Merchant")
/// // TODO: check  [order tokenId] != NULL
/// //TODO: if paymentOperation is PaymentOperation.preAuthorize:
/// Save order id in persistence for capturing the payment with // GeideaPaymentApi.capture
/// if ([[order detailedStatus] isEqual: @"Authorized"]) {
/// TODO: save order.orderId
/// }
/// }
/// }
/// }];
///
/// \endcodeseealso:
/// GDAmount, GDApplePayDetails, GDTokenizationDetails,GDConfigResponse,  GDCustomerDetails, GDAddress, GDOrderResponse, GDErrorResponse, GDApplePayResponse
/// since:
/// 1.0
/// version:
/// 1.0
+ (void)payWithGeideaFormWithTheAmount:(GDAmount * _Nonnull)amount showAddress:(BOOL)showAddress showEmail:(BOOL)showEmail tokenizationDetails:(GDTokenizationDetails * _Nullable)tokenizationDetails customerDetails:(GDCustomerDetails * _Nullable)customerDetails applePayDetails:(GDApplePayDetails * _Nullable)applePayDetails config:(GDConfigResponse * _Nullable)config eInvoiceId:(NSString * _Nullable)eInvoiceId viewController:(UIViewController * _Nonnull)viewController completion:(void (^ _Nonnull)(GDOrderResponse * _Nullable, GDErrorResponse * _Nullable))completion;
/// Starting the pay with token flow cardDetails already tokenized from Pay request
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     amount: GDAmount - SDK GDAmount object  <em>Required</em>
///     amount: Double <em>Required</em>
///     currency: String <em>Required</em>
///   </li>
///   <li>
///     tokenId: String <em>Required</em>
///   </li>
///   <li>
///     tokenizationDetails: GDTokenizationDetails <em>Required</em>
///     initiatedBy: String <em>Optional</em> Internet or Merchant
///     agreementID: String <em>Optional</em>
///     agreementType String <em>Optional</em> e.g “Installment”, “Recurring”, etc
///   </li>
///   <li>
///     eInvoice: String  <em>Optional</em> EInvoice id for paying an EInvoice created before
///   </li>
///   <li>
///     customerDetails: GDCustomerDetails - SDK GDCustomerDetails object use for internal customer reference for customer info  . <em>Optional</em>
///   </li>
///   <li>
///     GDCustomerDetails:
///     customerEmail: String <em>Optional</em>
///     callbackUrl: String <em>Optional</em>
///     merchantReferenceId: String <em>Optional</em>
///     paymentOperation: PaymentOperation <em>Optional</em>
///   </li>
///   <li>
///     shippingAddress: GDAddress <em>Optional</em>
///   </li>
///   <li>
///     GDAddress:
///     countryCode: String <em>Optional</em>
///     city: String <em>Optional</em>
///     street: String <em>Optional</em>
///     postCode: String <em>Optional</em>
///   </li>
///   <li>
///     billingAddress: GDAddress <em>Optional</em>
///   </li>
///   <li>
///     GDAddress:
///     countryCode: String <em>Optional</em>
///     city: String <em>Optional</em>
///     street: String <em>Optional</em>
///     postCode: String <em>Optional</em>
///   </li>
///   <li>
///     navController: UIViewController - Used for presenting SDK Payment flow. <em>Required</em>
///     two options for starting the SDK:
///     self type of : (UIViewController) the SDK will present modally from customer app UIViewController
///   </li>
///   <li>
///     navigationController type of: UINavigationController  the SDK will be pushed from customer app NavigationCotroller
///   </li>
///   <li>
///     completion: (GDOrderResponse?, GDErrorResponse?)  -> Void - The completion handler for customer app returned from SDK <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// Starting the pay with token payment flow
/// \code
/// let amount = GDAmount(amount: Double, currency: String)
/// let tokenizationDetails = GDTokenizationDetails(withCardOnFile: false, initiatedBy: "Internet " or "Merchant", agreementId: someString, agreementType: someString)
/// let shippingAddress = GDAddress(withCountryCode: shippingCountryCode: String, andCity: shippingCity: String, andStreet: shippingStreet: String, andPostCode: shippingPostalCode: String)
/// let billingAddress = GDAddress(withCountryCode: billingCountryCode: String, andCity: billingCity: String, andStreet: billingStreet: String, andPostCode: billingPostalCode: String)
/// let customerDetails = GDCustomerDetails(withEmail: email: String, andCallbackUrl: callback: String, merchantReferenceId: merchantRefid: String, shippingAddress: shippingAddress, billingAddress: billingAddress, paymentOperation: .pay or .preAuthorize etc..)
///
/// guard let navVC = UIApplication.shared.keyWindow?.rootViewController as? UINavigationController  else {
/// return
/// }
///
/// GeideaPaymentAPI.payWithToken(theAmount: amount, withTokenId: tokenId, tokenizationDetails: tokenizationDetails, andEInvoiceId: EInvoiceId or null, andCustomerDetails: customerDetails, navController: self, completion:{ response, error in
/// DispatchQueue.main.async {
///
/// if let err = error {
/// if err.errors.isEmpty {
/// var message = ""
/// if err.responseCode.isEmpty {
/// message = "\n responseMessage: \(err.responseMessage)"
/// } else {
/// message = "\n responseCode: \(err.responseCode)  \n responseMessage: \(err.responseMessage)"
/// }
/// //TODO: display relevant fields from GDErrorResponse
/// } else {
/// //TODO: display relevant fields from GDErrorResponse
/// }
///
/// } else {
/// guard let orderResponse = response else {
/// return
/// }
///
/// //TODO: display relevant fields from GDOrderResponse
/// //TODO: if paymentOperation is PaymentOperation.preAuthorize:
/// // Save order id in persistence for capturing the payment with // GeideaPaymentApi.capture
/// // if orderResponse.detailedStatus == "Authorized" {
/// // TODO: save order.orderId
/// // }
/// }
/// }
/// })
///
/// \endcode\code
/// UINavigationController *navVC =  (UINavigationController *)[[[UIApplication sharedApplication] keyWindow] rootViewController];
///
/// GDAmount *amount = [[GDAmount alloc] initWithAmount: [amunt doubleValue] currency: NSString *curency];
///
/// GDTokenizationDetails *tokenizationDetails = [[GDTokenizationDetails alloc] initWithCardOnFile:[_cardOnFileSwitch isOn] initiatedBy:[_initiatedByBtn currentTitle] agreementId: @"someString" agreementType: @"someString"];
///
/// GDAddress *shippingAddress = [[GDAddress alloc] initWithCountryCode:NSString *shippingCountryCode andCity:_shippingCityTF.text andStreet:_shippingStreetTF.text andPostCode:_shippingPostCodeTF.text];
///
/// GDAddress *billingAddress = [[GDAddress alloc] initWithCountryCode:_billingCountryCodeTF.text andCity:_billingCityTF.text andStreet:_billingStreetTF.text andPostCode:_billingPostCodeTF.text];
///
/// GDCustomerDetails *customerDetails = [[GDCustomerDetails alloc] initWithEmail:_emailTF.text andCallbackUrl:_callbackUrlTF.text merchantReferenceId:_merchantRefIDTF.text shippingAddress:shippingAddress billingAddress:billingAddress paymentOperation: PaymentOperationPay];
///
/// [GeideaPaymentAPI payWithTokenWithTheAmount:amount withTokenId:@"token id from from pay API call response" tokenizationDetails:tokenizationDetails andEInvoiceId: (EInvoiceId or null) andCustomerDetails:customerDetails navController: navVC completion:^(GDOrderResponse* order, GDErrorResponse* error) {
///
/// if (error != NULL) {
/// if (!error.errors || !error.errors.count) {
/// NSString *message;
/// if ( [error.responseCode length] == 0) {
/// message = [NSString stringWithFormat:@"\n responseMessage: %@", error.responseMessage];
/// } else {
/// message = [NSString stringWithFormat:@"\n responseCode: %@ \n responseMessage: %@ ", error.responseCode , error.responseMessage];
/// }
///
/// //TODO: display relevant fields from GDErrorResponse
/// } else {
/// //TODO: display relevant fields from GDErrorResponse
/// }
///
/// } else {
/// if (order != NULL) {
/// //TODO: display relevant fields from GDOrderResponse
/// //TODO: if paymentOperation is PaymentOperation.preAuthorize:
/// Save order id in persistence for capturing the payment with // GeideaPaymentApi.capture
/// if ([[order detailedStatus] isEqual: @"Authorized"]) {
/// TODO: save order.orderId
/// }
/// }
/// }
/// }];
///
/// \endcodeseealso:
/// GDAmount, GDTokenizationDetails, GDCustomerDetails, GDAddress, GDOrderResponse, GDErrorResponse
/// since:
/// 1.0
/// version:
/// 1.0
+ (void)payWithTokenWithTheAmount:(GDAmount * _Nonnull)amount withTokenId:(NSString * _Nonnull)token tokenizationDetails:(GDTokenizationDetails * _Nonnull)tokenizationDetails andEInvoiceId:(NSString * _Nullable)eInvoiceId andCustomerDetails:(GDCustomerDetails * _Nullable)customerDetails navController:(UIViewController * _Nonnull)navController completion:(void (^ _Nonnull)(GDOrderResponse * _Nullable, GDErrorResponse * _Nullable))completion;
/// Capture  flow
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     orderId: String from GDOrderResponse  (response from GeideaPaymentAPI.pay or  GeideaPaymentAPI.payWithToken)  <em>Required</em>
///   </li>
///   <li>
///     navController: UIViewController - Used for presenting SDK Payment flow. <em>Required</em>
///   </li>
///   <li>
///     two options for starting the SDK:
///   </li>
///   <li>
///     self type of : (UIViewController) the SDK will present modally from customer app UIViewController
///   </li>
///   <li>
///     navigationController type of: UINavigationController  the SDK will be pushed from customer app NavigationCotroller
///   </li>
///   <li>
///     completion: (GDOrderResponse?, GDErrorResponse?)  -> Void - The completion handler for customer app returned from SDK <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// Starting the payment flow
/// \code
/// guard let navVC = UIApplication.shared.keyWindow?.rootViewController as? UINavigationController  else {
/// return
/// }
///
/// GeideaPaymentAPI.capture(with: orderId, navController: **navVC** or **self**, completion:{ response, error in
/// DispatchQueue.main.async {
///
/// if let err = error {
/// if err.errors.isEmpty {
/// var message = ""
/// if err.responseCode.isEmpty {
/// message = "\n responseMessage: \(err.responseMessage)"
/// } else {
/// message = "\n responseCode: \(err.responseCode)  \n responseMessage: \(err.responseMessage)"
/// }
/// //TODO: display relevant fields from GDErrorResponse
/// } else {
/// //TODO: display relevant fields from GDErrorResponse
/// }
/// } else {
/// guard let orderResponse = response else {
/// return
/// }
///
/// //TODO: display relevant fields from GDOrderResponse
/// //TODO: remove OrderId and Capture button from UI
/// }
/// }
/// })
///
/// \endcode\code
/// UINavigationController *navVC =  (UINavigationController *)[[[UIApplication sharedApplication] keyWindow] rootViewController];
///
/// [GeideaPaymentAPI captureWith:self.orderId navController: navVC completion:^(GDOrderResponse* order, GDErrorResponse* error) {
///
/// if (error != NULL) {
/// if (!error.errors || !error.errors.count) {
/// NSString *message;
/// if ( [error.responseCode length] == 0) {
/// message = [NSString stringWithFormat:@"\n responseMessage: %@", error.responseMessage];
/// } else {
/// message = [NSString stringWithFormat:@"\n responseCode: %@ \n responseMessage: %@ ", error.responseCode , error.responseMessage];
/// }
///
/// //TODO: display relevant fields from GDErrorResponse
/// } else {
/// //TODO: display relevant fields from GDErrorResponse
/// }
///
/// } else {
/// if (order != NULL) {
/// //TODO: display relevant fields from GDOrderResponse
/// //TODO: remove OrderId and Capture button from UI
/// }
/// }
/// }
/// }];
///
/// \endcodeseealso:
/// GDOrderResponse, GDErrorResponse
/// since:
/// 1.0
/// version:
/// 1.0
+ (void)captureWith:(NSString * _Nonnull)orderId callbackUrl:(NSString * _Nullable)callbackUrl navController:(UIViewController * _Nonnull)navController completion:(void (^ _Nonnull)(GDOrderResponse * _Nullable, GDErrorResponse * _Nullable))completion;
+ (void)refundWith:(NSString * _Nonnull)orderId callbackUrl:(NSString * _Nullable)callbackUrl navController:(UIViewController * _Nonnull)navController completion:(void (^ _Nonnull)(GDOrderResponse * _Nullable, GDErrorResponse * _Nullable))completion;
+ (void)cancelWith:(NSString * _Nonnull)orderId callbackUrl:(NSString * _Nullable)callbackUrl navController:(UIViewController * _Nonnull)navController completion:(void (^ _Nonnull)(GDCancelResponse * _Nullable, GDErrorResponse * _Nullable))completion;
/// Starting the apple pay with flow
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     applePayDetails:GDApplePayDetails
///   </li>
///   <li>
///     hostViewController: your host ViewController
///   </li>
///   <li>
///     merchantIdentifier: String <em>Required</em> “merchant identifier from Apple account.”
///   </li>
///   <li>
///     buttonView: UIView as a placeholder where apple Pay Button will be placed
///   </li>
///   <li>
///     merchantRefId String <em>Optional</em>
///   </li>
///   <li>
///     callbackUrl: String <em>Optional</em>
///   </li>
///   <li>
///     amount: GDAmount - SDK GDAmount object  <em>Required</em>
///   </li>
///   <li>
///     amount: Double <em>Required</em>
///   </li>
///   <li>
///     currency: String <em>Required</em>
///   </li>
///   <li>
///     completion: (GDApplePayResponse?, GDErrorResponse?)  -> Void - The completion handler for customer app returned from SDK <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// \code
/// let amount = GDAmount(amount: safeAmount, currency: safeCurrency)
/// let applePayDetails = GDApplePayDetails(in: self, andButtonIn: applePayBtnView, forMerchantIdentifier: "merchant.company. etc.", withCallbackUrl: String, andReferenceId: String)
///
/// GeideaPaymentAPI.setupApplePay(forApplePayDetails: applePayDetails, with: amount, config: merchantConfig, completion: { response, error in
/// DispatchQueue.main.async {
///
/// if let err = error {
/// if err.errors.isEmpty {
/// var message = ""
/// if err.responseCode.isEmpty {
/// message = "\n responseMessage: \(err.responseMessage)"
/// } else {
/// message = "\n responseCode: \(err.responseCode)  \n responseMessage: \(err.responseMessage)"
/// }
/// //TODO: display relevant fields from GDErrorResponse
/// } else {
/// //TODO: display relevant fields from GDErrorResponse
/// }
///
/// } else {
/// guard let orderResponse = response else {
/// return
/// }
///
/// //TODO: display relevant fields from GDApplePayResponse
/// }
/// }
/// })
///
/// \endcode\code
///
/// GDAmount *amount = [[GDAmount alloc] initWithAmount: [amount doubleValue] currency: NSString *curency];
///
/// GDApplePayDetails *applePayDetails = [[GDApplePayDetails alloc] initIn:self andButtonIn:_applePayBtnView forMerchantIdentifier:@"merchant.etc" withCallbackUrl:String andReferenceId:String];
///
/// [GeideaPaymentAPI setupApplePayForApplePayDetails:applePayDetails with:amount config:GDConfigResponse completion:^(GDApplePayResponse* response, GDErrorResponse* error) {
///
/// if (error != NULL) {
/// if (!error.errors || !error.errors.count) {
/// NSString *message;
/// if ( [error.responseCode length] == 0) {
/// message = [NSString stringWithFormat:@"\n responseMessage: %@", error.responseMessage];
/// } else {
/// message = [NSString stringWithFormat:@"\n responseCode: %@ \n responseMessage: %@ ", error.responseCode , error.responseMessage];
/// }
///
/// //TODO: display relevant fields from GDErrorResponse
/// } else {
/// //TODO: display relevant fields from GDErrorResponse
/// }
///
/// } else {
/// if (response != NULL) {
/// //TODO: display relevant fields from GDApplePayResponse
/// }
/// }
/// }];
///
/// \endcodeseealso:
/// GDAmount, GDApplePayDetails, GDConfigResponse, GDApplePayResponse, GDErrorResponse
/// since:
/// 1.0
/// version:
/// 1.0
+ (void)setupApplePayForApplePayDetails:(GDApplePayDetails * _Nonnull)applePayDetails with:(GDAmount * _Nonnull)amount config:(GDConfigResponse * _Nullable)config completion:(void (^ _Nonnull)(GDOrderResponse * _Nullable, GDErrorResponse * _Nullable))completion;
/// Getting card scheme logo
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     cardType: CardType  <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// getting the image
/// \code
/// cardSchemeLogoIV.image = GeideaPaymentAPI.getCardSchemeLogo(withCardNumber: cardNumber)
///
/// or if you don't want detector
///
/// cardSchemeLogoIV.image = GeideaPaymentAPI.getCardSchemeLogo(withCardType: cardType)
///
/// \endcode\code
///
/// _cardSchemeLogoIV.image = [GeideaPaymentAPI getCardSchemeLogoWithCardNumber:cardNumber];
///
/// or if you don't want detector
///
/// _cardSchemeLogoIV.image  = [GeideaPaymentAPI getCardSchemeLogoWithCardType:CardTypeVisa]
///
/// \endcodesince:
/// 1.0
/// version:
/// 1.0
+ (UIImage * _Nullable)getCardSchemeLogoWithCardType:(enum CardType)cardType SWIFT_WARN_UNUSED_RESULT;
+ (UIImage * _Nullable)getCardSchemeLogoWithCardNumber:(NSString * _Nullable)cardNumber SWIFT_WARN_UNUSED_RESULT;
/// Create EInvoice
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     eInvoiceParams: GDEInvoiceDetails  <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// creating the EInvoice
/// \code
/// GeideaPaymentAPI.createInvoice(with: invoiceDetails, completion:{ response, error in
///     if let invoice = response?.eInvoice {
///       // save EInvoiceId for future payment
///     }
///
/// })
///
/// \endcode\code
/// [GeideaPaymentAPI createInvoiceWith:invoiceDetails completion:^(GDEInvoiceResponse* order, GDErrorResponse* error) {
///    //Use response
/// }];
///
/// \endcodeseealso:
/// GDAmount, GDEInvoiceDetails
/// since:
/// 1.0
/// version:
/// 1.0
+ (void)createInvoiceWith:(GDEInvoiceDetails * _Nonnull)eInvoiceParams completion:(void (^ _Nonnull)(GDEInvoiceResponse * _Nullable, GDErrorResponse * _Nullable))completion;
/// Update EInvoice
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     eInvoiceParams: GDEInvoiceDetails  <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// updating  EInvoice
/// \code
///    GeideaPaymentAPI.updateInvoice(with: invoiceDetails, completion:{ response, error in
///        //Use response
///    })
/// })
///
/// \endcode\code
/// [GeideaPaymentAPI updateInvoiceWith:invoiceDetails completion:^(GDEInvoiceResponse* order, GDErrorResponse* error) {
/// //Use response
/// }];
///
/// \endcodeseealso:
/// GDAmount, GDEInvoiceDetails
/// since:
/// 1.0
/// version:
/// 1.0
+ (void)updateInvoiceWith:(GDEInvoiceDetails * _Nonnull)eInvoiceParams completion:(void (^ _Nonnull)(GDEInvoiceResponse * _Nullable, GDErrorResponse * _Nullable))completion;
/// Get EInvoice
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     eInvoiceId: String  <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// getting  EInvoice
/// \code
///    GeideaPaymentAPI.getInvoice(with: eInvoice, completion:{ response, error in
///        //Use response
///    })
/// })
///
/// \endcode\code
///    [GeideaPaymentAPI getInvoiceWith:eInvoiceId completion:^(GDEInvoiceResponse* response, GDErrorResponse* error) {
///        //Use response
///    }];
///
/// \endcodesince:
/// 1.0
/// version:
/// 1.0
+ (void)getInvoiceWith:(NSString * _Nonnull)eInvoiceId completion:(void (^ _Nonnull)(GDEInvoiceResponse * _Nullable, GDErrorResponse * _Nullable))completion;
/// Delete EInvoice
/// <ul>
///   <li>
///     Parameters:
///   </li>
///   <li>
///     eInvoiceId: String  <em>Required</em>
///   </li>
/// </ul>
/// <h1>Examples</h1>
/// deleting  EInvoice
/// \code
///    GeideaPaymentAPI.deleteInvoice(with: eInvoice, completion:{ response, error in
///        //Use response
///    })
/// })
///
/// \endcode\code
/// [GeideaPaymentAPI deleteInvoiceWith:eInvoiceId completion:^(GDEInvoiceResponse*   response, GDErrorResponse* error) {
///    //Use response
/// }];
///
/// \endcodesince:
/// 1.0
/// version:
/// 1.0
+ (void)deleteInvoiceWith:(NSString * _Nonnull)eInvoiceId completion:(void (^ _Nonnull)(GDEInvoiceResponse * _Nullable, GDErrorResponse * _Nullable))completion;
+ (void)getOrdersWith:(GDOrdersFilter * _Nullable)orderParams completion:(void (^ _Nonnull)(GDOrdersResponse * _Nullable, GDErrorResponse * _Nullable))completion;
+ (void)getOrderWith:(NSString * _Nonnull)orderId completion:(void (^ _Nonnull)(GDOrderResponse * _Nullable, GDErrorResponse * _Nullable))completion;
+ (void)getMerchantConfigWithCompletion:(void (^ _Nonnull)(GDConfigResponse * _Nullable, GDErrorResponse * _Nullable))completion;
/// Switch networking environment for testing purposes
/// <h1>Examples</h1>
/// Add this to check if credentials are already stored in the SDK Secure storage
/// \code
/// GeideaPaymentAPI.setEnvironment(environment: Environment.dev)
/// GeideaPaymentAPI.setEnvironment(environment: Environment.test)
/// GeideaPaymentAPI.setEnvironment(environment: Environment.preprod)
/// GeideaPaymentAPI.setEnvironment(environment: Environment.prod)
///
/// \endcode\code
/// [GeideaPaymentAPI setEnvironmentWithEnvironment:EnvironmentDev];
/// [GeideaPaymentAPI setEnvironmentWithEnvironment:EnvironmentTest];
/// [GeideaPaymentAPI setEnvironmentWithEnvironment:EnvironmentPreprod];
/// [GeideaPaymentAPI setEnvironmentWithEnvironment:EnvironmentProd];
///
/// \endcodesince:
/// 1.0
/// version:
/// 1.0
+ (void)setEnvironmentWithEnvironment:(enum Environment)environment;
+ (void)removeCredentials;
+ (void)updateCredentialsWithMerchantKey:(NSString * _Nonnull)merchantKey andPassword:(NSString * _Nonnull)password;
+ (void)startEInvoiceWithEInvoiceID:(NSString * _Nullable)eInvoiceId viewController:(UIViewController * _Nonnull)viewController completion:(void (^ _Nonnull)(GDEInvoiceResponse * _Nullable, GDErrorResponse * _Nullable))completion;
+ (NSString * _Nullable)getModelStringWithOrder:(GDOrderResponse * _Nonnull)order SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nullable)getConfigStringWithConfig:(GDConfigResponse * _Nonnull)config SWIFT_WARN_UNUSED_RESULT;
+ (NSString * _Nullable)getEInvoiceStringWithOrder:(GDEInvoiceResponse * _Nonnull)order SWIFT_WARN_UNUSED_RESULT;
@end


typedef SWIFT_ENUM(NSInteger, LogLevel, closed) {
/// No log will be shown. Recommended for production environments.
  LogLevelNone = 0,
/// Only warnings and errors. Recommended for develop environments.
  LogLevelError = 1,
/// Errors and relevant information. Recommended for test integrating.
  LogLevelInfo = 2,
/// Request and Responses to GeideaPaymentSDK’s server will be displayed. Not recommended to use, only for debugging.
  LogLevelDebug = 3,
};



SWIFT_CLASS("_TtC16GeideaPaymentSDK11PayResponse")
@interface PayResponse : NSObject
- (nonnull instancetype)init SWIFT_UNAVAILABLE;
+ (nonnull instancetype)new SWIFT_DEPRECATED_MSG("-init is unavailable");
@end

typedef SWIFT_ENUM(NSInteger, PaymentOperation, closed) {
  PaymentOperationPay = 0,
  PaymentOperationPreAuthorize = 1,
  PaymentOperationAuthorizeCapture = 2,
  PaymentOperationNONE = 3,
};








#if __has_attribute(external_source_symbol)
# pragma clang attribute pop
#endif
#pragma clang diagnostic pop
#endif
